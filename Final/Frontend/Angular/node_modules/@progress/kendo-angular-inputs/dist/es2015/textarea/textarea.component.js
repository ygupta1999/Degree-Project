/**-----------------------------------------------------------------------------------------
* Copyright Â© 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as tslib_1 from "tslib";
var TextAreaComponent_1;
import { Component, HostBinding, Input, Output, ElementRef, EventEmitter, NgZone, Renderer2, ChangeDetectorRef, Injector, forwardRef } from '@angular/core';
import { fromEvent } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
import { NG_VALUE_ACCESSOR, NgControl } from '@angular/forms';
import { KendoInput, guid, isDocumentAvailable, hasObservers, Keys } from '@progress/kendo-angular-common';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { TextFieldsBase } from '../text-fields-common/text-fields-base';
import { areSame, isPresent } from '../common/utils';
import { invokeElementMethod } from '../common/dom-utils';
import { closest } from './../common/dom-utils';
import { validatePackage } from '@progress/kendo-licensing';
import { packageMetadata } from '../package-metadata';
const resizeClasses = {
    'vertical': 'k-resize-vertical',
    'horizontal': 'k-resize-horizontal',
    'both': 'k-resize-both',
    'none': 'k-resize-none',
    'auto': 'k-resize-none'
};
const FOCUSED = 'k-state-focus';
/**
 * Represents the [Kendo UI TextArea component for Angular]({% slug overview_textarea %}).
 */
let TextAreaComponent = TextAreaComponent_1 = class TextAreaComponent extends TextFieldsBase {
    constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {
        super(localizationService, ngZone, changeDetector, renderer, injector, hostElement);
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        this.injector = injector;
        this.hostElement = hostElement;
        /**
         * @hidden
         */
        this.focusableId = `k-${guid()}`;
        this.hostClass = true;
        /**
         * Specifies the flow direction of the TextArea sections. This property is useful when adornments are used, in order to specify
         * their position in relation to the textarea element.
         *
         * The possible values are:
         * * `vertical`(Default) &mdash;TextArea sections are placed from top to bottom.
         * * `horizontal`&mdash;TextArea sections are placed from left to right in `ltr`, and from right to left in `rtl` mode.
         */
        this.flow = 'vertical';
        /**
         * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Configures the resize behavior of the TextArea.
         *
         * The possible values are:
         * * `vertical`(Default)&mdash;The TextArea component can be resized only vertically.
         * * `horizontal`&mdash;The TextArea component can be resized only horizontally.
         * * `both`&mdash;The TextArea component can be resized in both (horizontal and vertical) directions.
         * * `auto`&mdash;Specifies whether the TextArea component will adjust its height automatically, based on the content.
         * * `none`&mdash;The TextArea cannot be resized.
         *
         */
        this.resizable = 'vertical';
        /**
         * Fires each time the user focuses the TextArea component.
         *
         * > To wire the event programmatically, use the `onFocus` property.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-textarea (focus)="handleFocus()"></kendo-textarea>
         * `
         * })
         * class AppComponent {
         *   public handleFocus(): void {
         *      console.log('Component is focused');
         *   }
         * }
         * ```
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the TextArea component gets blurred.
         *
         * > To wire the event programmatically, use the `onBlur` property.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-textarea (blur)="handleBlur()"></kendo-textarea>
         * `
         * })
         * class AppComponent {
         *   public handleBlur(): void {
         *      console.log('Component is blurred');
         *   }
         * }
         * ```
         */
        this.onBlur = new EventEmitter();
        /**
         * Fires each time the value is changed or the component is blurred
         * ([see example]({% slug overview_textarea %}#toc-events)).
         * When the component value is changed programmatically or via its form control binding, the valueChange event is not emitted.
         */
        this.valueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.handleInput = (ev) => {
            let incomingValue = ev.target.value;
            this.updateValue(incomingValue);
            this.resize();
        };
        /**
         * @hidden
         */
        this.handleInputFocus = () => {
            if (!this.disabled) {
                if (this.selectOnFocus && this.value) {
                    this.ngZone.run(() => {
                        setTimeout(() => { this.selectAll(); });
                    });
                }
                if (hasObservers(this.onFocus)) {
                    if (!this.isFocused) {
                        this.ngZone.run(() => {
                            this.onFocus.emit();
                        });
                    }
                }
                if (hasObservers(this.inputFocus)) {
                    if (!this.focusChangedProgrammatically) {
                        this.ngZone.run(() => {
                            this.inputFocus.emit();
                        });
                    }
                }
                this.ngZone.run(() => {
                    this.isFocused = true;
                });
            }
        };
        validatePackage(packageMetadata);
        this.direction = localizationService.rtl ? 'rtl' : 'ltr';
    }
    get flowCol() {
        return this.flow === 'vertical';
    }
    get flowRow() {
        return this.flow === 'horizontal';
    }
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    ngAfterViewInit() {
        const hostElement = this.hostElement.nativeElement;
        let cursorInsideWrapper = false;
        let tabbing = false;
        this.ngZone.runOutsideAngular(() => {
            // focusIn and focusOut are relative to the host element
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusin', () => {
                if (!this.isFocused) {
                    this.ngZone.run(() => {
                        this.onFocus.emit();
                        this.isFocused = true;
                    });
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'focusout', (args) => {
                if (!this.isFocused) {
                    return;
                }
                if (tabbing) {
                    const closestTextbox = closest(args.relatedTarget, (element) => element === this.hostElement.nativeElement);
                    if (!closestTextbox) {
                        this.handleBlur();
                    }
                    tabbing = false;
                }
                else {
                    if (!cursorInsideWrapper) {
                        this.handleBlur();
                    }
                }
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseenter', () => {
                cursorInsideWrapper = true;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'mouseleave', () => {
                cursorInsideWrapper = false;
            }));
            this.subscriptions.add(this.renderer.listen(hostElement, 'keydown', (args) => {
                if (args.keyCode === Keys.Tab) {
                    tabbing = true;
                }
                else {
                    tabbing = false;
                }
            }));
        });
    }
    ngOnInit() {
        this.control = this.injector.get(NgControl, null);
        if (isDocumentAvailable() && this.resizable === 'auto') {
            this.resizeSubscription = fromEvent(window, 'resize')
                .pipe((debounceTime(50)))
                .subscribe(() => this.resize());
        }
        if (this.hostElement) {
            this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
        }
        this.subscriptions = this.localizationService.changes.subscribe(({ rtl }) => {
            this.direction = rtl ? 'rtl' : 'ltr';
        });
    }
    ngOnChanges(changes) {
        const hostElement = this.hostElement.nativeElement;
        const element = this.input.nativeElement;
        if (changes.resizable) {
            if (this.resizable === 'auto') {
                this.initialHeight = element.offsetHeight;
            }
            else {
                this.renderer.setStyle(element, 'overflow-y', 'auto');
                this.renderer.setStyle(element, 'resize', 'both');
                element.style.height = `${this.initialHeight}px`;
            }
        }
        if (changes.cols) {
            if (isPresent(changes.cols.currentValue)) {
                this.renderer.setStyle(hostElement, 'width', 'auto');
            }
            else {
                this.renderer.removeStyle(hostElement, 'width');
            }
        }
    }
    ngAfterViewChecked() {
        this.resize();
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.ngChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.ngTouched = fn;
    }
    updateValue(value) {
        if (!areSame(this.value, value)) {
            this.ngZone.run(() => {
                this.value = value;
                this.ngChange(value);
                this.valueChange.emit(value);
                this.changeDetector.markForCheck();
            });
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        if (this.resizeSubscription) {
            this.resizeSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    get resizableClass() {
        return resizeClasses[this.resizable];
    }
    /**
     * Focuses the TextArea component.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="textarea.focus()">Focus the textarea</button>
     *  <kendo-textarea #textarea></kendo-textarea>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    focus() {
        if (!this.input) {
            return;
        }
        this.focusChangedProgrammatically = true;
        this.isFocused = true;
        this.input.nativeElement.focus();
        this.focusChangedProgrammatically = false;
    }
    /**
     * Blurs the TextArea component.
     */
    blur() {
        this.focusChangedProgrammatically = true;
        const isFocusedElement = this.hostElement.nativeElement.querySelector(':focus');
        if (isFocusedElement) {
            isFocusedElement.blur();
        }
        this.isFocused = false;
        this.focusChangedProgrammatically = false;
    }
    resize() {
        if (this.resizable !== 'auto') {
            return;
        }
        const element = this.input.nativeElement;
        this.renderer.setStyle(element, 'overflow-y', 'hidden');
        this.renderer.setStyle(element, 'height', `${this.initialHeight}px`);
        const scrollHeight = element.scrollHeight;
        if (scrollHeight > this.initialHeight) {
            element.style.height = `${scrollHeight}px`;
        }
    }
    get isFocused() {
        return this._isFocused;
    }
    set isFocused(value) {
        if (this._isFocused !== value && this.hostElement) {
            const element = this.hostElement.nativeElement;
            if (value && !this.disabled) {
                this.renderer.addClass(element, FOCUSED);
            }
            else {
                this.renderer.removeClass(element, FOCUSED);
            }
            this._isFocused = value;
        }
    }
    handleBlur() {
        this.ngZone.run(() => {
            if (!this.focusChangedProgrammatically) {
                this.onBlur.emit();
            }
            this.isFocused = false;
        });
    }
    setSelection(start, end) {
        if (this.isFocused) {
            invokeElementMethod(this.input, 'setSelectionRange', start, end);
        }
    }
    selectAll() {
        if (this.value) {
            this.setSelection(0, this.value.length);
        }
    }
};
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], TextAreaComponent.prototype, "focusableId", void 0);
tslib_1.__decorate([
    HostBinding('class.k-textarea'),
    tslib_1.__metadata("design:type", Boolean)
], TextAreaComponent.prototype, "hostClass", void 0);
tslib_1.__decorate([
    HostBinding('class.k-flex-col'),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], TextAreaComponent.prototype, "flowCol", null);
tslib_1.__decorate([
    HostBinding('class.k-flex-row'),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [])
], TextAreaComponent.prototype, "flowRow", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], TextAreaComponent.prototype, "flow", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], TextAreaComponent.prototype, "rows", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], TextAreaComponent.prototype, "cols", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], TextAreaComponent.prototype, "maxlength", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], TextAreaComponent.prototype, "tabindex", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], TextAreaComponent.prototype, "tabIndex", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], TextAreaComponent.prototype, "resizable", void 0);
tslib_1.__decorate([
    Output('focus'),
    tslib_1.__metadata("design:type", EventEmitter)
], TextAreaComponent.prototype, "onFocus", void 0);
tslib_1.__decorate([
    Output('blur'),
    tslib_1.__metadata("design:type", EventEmitter)
], TextAreaComponent.prototype, "onBlur", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], TextAreaComponent.prototype, "valueChange", void 0);
TextAreaComponent = TextAreaComponent_1 = tslib_1.__decorate([
    Component({
        exportAs: 'kendoTextArea',
        providers: [
            LocalizationService,
            { provide: L10N_PREFIX, useValue: 'kendo.textarea' },
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => TextAreaComponent_1),
                multi: true
            },
            { provide: KendoInput, useExisting: forwardRef(() => TextAreaComponent_1) }
        ],
        selector: 'kendo-textarea',
        template: `
        <textarea
            #input
            [attr.aria-multiline]="true"
            [attr.aria-disabled]="disabled ? true : undefined"
            [attr.aria-readonly]="readonly ? true : undefined"
            class="k-input"
            [ngClass]="resizableClass"
            [id]="focusableId"
            [value]="value"
            [attr.placeholder]="placeholder"
            [disabled]="disabled"
            [readonly]="readonly"
            [attr.rows]="rows"
            [attr.cols]="cols"
            [attr.tabindex]="tabIndex"
            [attr.title]="title"
            [attr.maxlength]="maxlength"
            [kendoEventsOutsideAngular]="{
                focus: handleInputFocus,
                blur: handleInputBlur,
                input: handleInput}">
            </textarea>
            <ng-content select="kendo-textarea-suffix"></ng-content>
    `
    }),
    tslib_1.__metadata("design:paramtypes", [LocalizationService,
        NgZone,
        ChangeDetectorRef,
        Renderer2,
        Injector,
        ElementRef])
], TextAreaComponent);
export { TextAreaComponent };
