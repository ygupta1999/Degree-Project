/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __metadata, __param } from 'tslib';
import { EventEmitter, ɵɵdefineInjectable, ɵɵinject, LOCALE_ID, Injectable, Inject, Pipe, NgModule } from '@angular/core';
import { validatePackage } from '@progress/kendo-licensing';
import { dateFormatNames, dateFieldName, firstDay, format, formatDate, formatNumber, load, numberSymbols, parseDate, parseNumber, splitDateFormat, toString, weekendRange, setData, localeInfo } from '@telerik/kendo-intl';

/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
const packageMetadata = {
    name: '@progress/kendo-angular-intl',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1611052171,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

const DOCS_URL = 'http://www.telerik.com/kendo-angular-ui/components/internationalization/troubleshooting/';
/**
 * @hidden
 */
const errorSolutions = {
    'NoCurrency': `Solution: ${DOCS_URL}#toc-no-currency`,
    'NoCurrencyDisplay': `Solution: ${DOCS_URL}#toc-no-currency-display`,
    'NoCurrencyRegion': `Solution: ${DOCS_URL}#toc-no-currency-region`,
    'NoDateFieldNames': `Solution: ${DOCS_URL}#toc-no-date-filed-names`,
    'NoFirstDay': `Solution: ${DOCS_URL}#toc-no-first-day`,
    'NoGMTInfo': `Solution: ${DOCS_URL}#toc-no-gmt-info`,
    'NoLocale': `Solution: ${DOCS_URL}#toc-no-locale`,
    'NoValidCurrency': `Solution: ${DOCS_URL}#toc-no-valid-currency`,
    'NoWeekData': `Solution: ${DOCS_URL}#toc-no-week-data`
};

function formatMessage(error) {
    const message = error.message;
    const errorSolution = errorSolutions[Object.keys(errorSolutions).filter(key => message.indexOf(key) === 0)[0]];
    return errorSolution ? `${message} ${errorSolution}` : message;
}
function intlMethod(fn) {
    return function (...values) {
        try {
            return fn.apply(null, values);
        }
        catch (error) {
            error.message = formatMessage(error);
            throw error;
        }
    };
}
/**
 * @hidden
 */
const dateFormatNames$1 = intlMethod(dateFormatNames);
/**
 * @hidden
 */
const dateFieldName$1 = intlMethod(dateFieldName);
/**
 * @hidden
 */
const firstDay$1 = intlMethod(firstDay);
/**
 * @hidden
 */
const format$1 = intlMethod(format);
/**
 * @hidden
 */
const formatDate$1 = intlMethod(formatDate);
/**
 * @hidden
 */
const formatNumber$1 = intlMethod(formatNumber);
/**
 * @hidden
 */
const load$1 = intlMethod(load);
/**
 * @hidden
 */
const numberSymbols$1 = intlMethod(numberSymbols);
/**
 * @hidden
 */
const parseDate$1 = intlMethod(parseDate);
/**
 * @hidden
 */
const parseNumber$1 = intlMethod(parseNumber);
/**
 * @hidden
 */
const splitDateFormat$1 = intlMethod(splitDateFormat);
/**
 * @hidden
 */
const toString$1 = intlMethod(toString);
/**
 * @hidden
 */
const weekendRange$1 = intlMethod(weekendRange);
/**
 * Sets a pre-built locale.
 *
 * @params data - The pre-built locale data.
 */
const setData$1 = (data) => setData(data);
/**
 * Retrieves the locale data for the specified locale.
 *
 * @params locale - The locale id.
 * @returns data - The locale data.
 */
const localeData = (locale) => {
    try {
        return localeInfo(locale);
    }
    catch (error) {
        error.message = formatMessage(error);
        throw error;
    }
};

const LOCALE_REGEX = /_/g;
/**
 * @hidden
 */
function cldrServiceFactory(localeId) {
    return new CldrIntlService(localeId);
}
/**
 * An abstract base class that implements
 * the Internationalization service methods
 * for the current locale.
 */
let IntlService = class IntlService {
    /**
     * @hidden
     */
    constructor() {
        /**
         * @hidden
         */
        this.changes = new EventEmitter();
        validatePackage(packageMetadata);
    }
    /**
     * Notifies that the service was changed.
     */
    notify() {
        this.changes.emit();
    }
};
IntlService.ɵfac = function IntlService_Factory(t) { return new (t || IntlService)(); };
IntlService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IntlService, factory: function IntlService_Factory(t) { let r = null; if (t) {
        r = new t();
    }
    else {
        r = cldrServiceFactory(ɵngcc0.ɵɵinject(LOCALE_ID));
    } return r; }, providedIn: 'root' });
IntlService.ngInjectableDef = ɵɵdefineInjectable({ factory: function IntlService_Factory() { return cldrServiceFactory(ɵɵinject(LOCALE_ID)); }, token: IntlService, providedIn: "root" });
IntlService = __decorate([ __metadata("design:paramtypes", [])
], IntlService);
/**
 * The Internationalization service implemented by using
 * the CLDR Database via the `@telerik/kendo-intl` package.
 */
let CldrIntlService = class CldrIntlService extends IntlService {
    /**
     * Creates a new instance of the service with the ID of the specified locale.
     *
     * Note that the parts of the locale ID can be separated by either `_` (underscore)
     * or `-` (dash).
     *
     * @param localeId - The default locale ID.
     */
    constructor(localeId) {
        super();
        this.localeId = localeId;
    }
    /**
     * Gets or sets the current locale ID.
     */
    get localeId() {
        return this.locale;
    }
    set localeId(value) {
        // Angular locales use underscore, for example, en_US
        // while IETF BCP-47 specifies a dash.
        // https://tools.ietf.org/html/bcp47
        const locale = value.replace(LOCALE_REGEX, '-');
        if (locale !== this.locale) {
            this.locale = locale;
            this.notify();
        }
    }
    /**
     * Formats a string with placeholders such as
     * `Total amount {0:c}`.
     *
     * @param format - The format string.
     * @param values - One or more values to output in the format string placeholders.
     * @return - The formatted string.
     */
    format(format$$1, ...values) {
        return format$1(format$$1, values, this.localeId);
    }
    /**
     * Converts an object into a string based on the specified format.
     *
     * @param value - The value to format.
     * @param format - The format to use.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted object.
     */
    toString(value, format$$1, localeId) {
        return toString$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Converts a `Date` object into a string based on the specified format.
     * If no format is provided, the default short date format is used.
     *
     * @param value - The date to format.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted date.
     */
    formatDate(value, format$$1, localeId) {
        return formatDate$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Converts a string into a `Date` object based on the specified format.
     *
     * @param value - The string to convert.
     * @param format - The format strings or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The parsed date.
     */
    parseDate(value, format$$1, localeId) {
        return parseDate$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Converts a string into a `Number`.
     *
     * @param value - The string to convert.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The parsed number.
     */
    parseNumber(value, format$$1, localeId) {
        return parseNumber$1(value, localeId || this.localeId, format$$1);
    }
    /**
     * Converts a `Number` into a string based on the specified format.
     *
     * @param value - The number to format.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted number.
     */
    formatNumber(value, format$$1, localeId) {
        return formatNumber$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Returns the date names from the current locale based on the option.
     *
     * The available `type` values are:
     * - `era`
     * - `year`
     * - `quarter`
     * - `month`
     * - `week`
     * - `day`
     * - `dayperiod`
     * - `hour`
     * - `minute`
     * - `second`
     * - `zone`
     *
     * The available `nameType` values are:
     * - `wide`
     * - `narrow`
     * - `short`
     *
     * @param options - Detailed configuration for the desired date field name.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The day names from the current locale based on the option.
     * @returns The localized date field name from the current locale based on the option.
     *
     * @example
     * ```
     * dateFieldName({ type: 'day' });                      //returns 'day';
     * dateFieldName({ type: 'day', nameType: 'wide' });    //returns 'day';
     * dateFieldName({ type: 'month', nameType: 'short' }); //returns 'mo.';
     * dateFieldName({ type: 'month', nameType: 'wide' });  //returns 'month';
     * ```
     */
    dateFieldName(options, localeId) {
        return dateFieldName$1(options, localeId || this.localeId);
    }
    /**
     * Returns a localized date field name based on specific dateFieldName options.
     *
     * The available type values are:
     * - `day`
     * - `dayperiod`
     * - `months`
     * - `quarters`
     * - `eras`
     *
     * @param options - Detailed configuration for the desired date format.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The day names from the current locale based on the option.
     */
    dateFormatNames(options, localeId) {
        return dateFormatNames$1(localeId || this.localeId, options);
    }
    /**
     * Splits the date format into objects containing information about each part of the pattern.
     *
     * @param format The format string or options.
     * @param localeId The optional locale id. If not specified, the `"en"` locale id is used.
     * @returns The date format parts.
     */
    splitDateFormat(format$$1, localeId) {
        return splitDateFormat$1(format$$1, localeId || this.localeId);
    }
    /**
     * Returns the number symbols from the current locale based on the option.
     *
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The number symbols from the current locale.
     */
    numberSymbols(localeId) {
        return numberSymbols$1(localeId || this.localeId);
    }
    /**
     * Returns the first day index starting from Sunday.
     *
     * @param localeId - The locale ID. Defaults to the current locale ID.
     * @return - The index of the first day of the week (0 == Sunday).
     */
    firstDay(localeId) {
        return firstDay$1(localeId || this.localeId);
    }
    /**
     * Returns the start and end index of the locale weekend starting from Sunday.
     *
     * @param localeId - The locale ID. Defaults to the current locale ID.
     * @return - The the start and end index of the locale weekend (0 == Sunday).
     */
    weekendRange(localeId) {
        return weekendRange$1(localeId || this.localeId);
    }
};
CldrIntlService.ɵfac = function CldrIntlService_Factory(t) { return new (t || CldrIntlService)(ɵngcc0.ɵɵinject(LOCALE_ID)); };
CldrIntlService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CldrIntlService, factory: function (t) { return CldrIntlService.ɵfac(t); } });
CldrIntlService = __decorate([ __param(0, Inject(LOCALE_ID)),
    __metadata("design:paramtypes", [String])
], CldrIntlService);

const isNumeric = (value) => !isNaN(value - parseFloat(value));
const ɵ0 = isNumeric;
/**
 * Formats a date value to a string based on the requested format.
 * This pipe uses the [IntlService]({% slug api_intl_intlservice %}).
 *
 * @example
 * ```ng-template-no-run
 * <ul>
 *    <li>{{date | kendoDate }}</li>
 *    <li>{{milliseconds | kendoDate: 'M/dd/yyy' }}</li>
 *    <li>{{stringDate | kendoDate: 'G' }}</li>
 * </ul>
 * ```
 */
let DatePipe = class DatePipe {
    /**
     * @hidden
     */
    constructor(intlService) {
        this.intlService = intlService;
    }
    /**
     * Converts a `Date` object into a string based on the specified format.
     * If no format is provided, the default short date format is used.
     *
     * @param value - The date to format.
     * @param format - The format string or options.
     * @param localeId - (Optional) The ID of the locale which will be used instead of the default one.
     * @return - The formatted date.
     */
    transform(value, format$$1 = "", localeId) {
        value = this.normalize(value);
        if (value) {
            return this.intlService.formatDate(value, format$$1, localeId);
        }
        return value;
    }
    normalize(value) {
        if (value && typeof value === 'string') {
            value = this.intlService.parseDate(value);
        }
        else if (value && isNumeric(value)) {
            value = new Date(parseFloat(value));
        }
        return value;
    }
};
DatePipe.ɵfac = function DatePipe_Factory(t) { return new (t || DatePipe)(ɵngcc0.ɵɵdirectiveInject(IntlService)); };
DatePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "kendoDate", type: DatePipe, pure: true });
DatePipe = __decorate([ __metadata("design:paramtypes", [IntlService])
], DatePipe);

/**
 * Formats a number value to a string based on the requested format.
 * This pipe uses the [`IntlService`]({% slug api_intl_intlservice %}).
 *
 * @example
 * ```ng-template-no-run
 *   <ul>
 *     <li>{{decimal | kendoNumber:'c' }}</li>
 *     <li>{{stringNumber | kendoNumber:'p' }}</li>
 *     <li>{{int | kendoNumber:'##.00' }}</li>
 *  </ul>
 * ```
 */
let NumberPipe = class NumberPipe {
    /**
     * @hidden
     */
    constructor(intlService) {
        this.intlService = intlService;
    }
    /**
     * Converts a `Number` object into a string based on the specified format.
     * If no format is provided, the value is formatted as decimal number using the
     * [`"n"`](https://github.com/telerik/kendo-intl/blob/master/docs/num-formatting/index.md#standard) format.
     *
     * @param value - The numer that will be formatted.
     * @param format - The format string or options.
     * @param localeId - (Optional) The locale ID that will be used in place of the default one.
     * @return - The formatted number.
     */
    transform(value, format$$1, localeId) {
        if (typeof value === 'string') {
            value = this.intlService.parseNumber(value);
        }
        if (value !== null && value !== undefined) {
            return this.intlService.formatNumber(value, format$$1, localeId);
        }
        return value;
    }
};
NumberPipe.ɵfac = function NumberPipe_Factory(t) { return new (t || NumberPipe)(ɵngcc0.ɵɵdirectiveInject(IntlService)); };
NumberPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "kendoNumber", type: NumberPipe, pure: true });
NumberPipe = __decorate([ __metadata("design:paramtypes", [IntlService])
], NumberPipe);

const pipes = [
    DatePipe,
    NumberPipe
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}docs/ts/latest/guide/ngmodule.html)
 * definition for the Intl services.
 */
let IntlModule = class IntlModule {
};
IntlModule.ɵfac = function IntlModule_Factory(t) { return new (t || IntlModule)(); };
IntlModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IntlModule });
IntlModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(IntlService, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
                useFactory: cldrServiceFactory,
                deps: [LOCALE_ID]
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CldrIntlService, [{
        type: Injectable
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DatePipe, [{
        type: Pipe,
        args: [{
                name: 'kendoDate'
            }]
    }], function () { return [{ type: IntlService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NumberPipe, [{
        type: Pipe,
        args: [{
                name: 'kendoNumber'
            }]
    }], function () { return [{ type: IntlService }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IntlModule, { declarations: [DatePipe, NumberPipe], exports: [DatePipe, NumberPipe] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(IntlModule, [{
        type: NgModule,
        args: [{
                declarations: [pipes],
                exports: [pipes]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { cldrServiceFactory, IntlService, CldrIntlService, DatePipe, ɵ0, NumberPipe, IntlModule, dateFormatNames$1 as dateFormatNames, dateFieldName$1 as dateFieldName, firstDay$1 as firstDay, format$1 as format, formatDate$1 as formatDate, formatNumber$1 as formatNumber, load$1 as load, numberSymbols$1 as numberSymbols, parseDate$1 as parseDate, parseNumber$1 as parseNumber, splitDateFormat$1 as splitDateFormat, toString$1 as toString, weekendRange$1 as weekendRange, setData$1 as setData, localeData };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozt5Q0FBRTtBQUNGO0FBQ0EsMEJBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eUlBQUU7QUFDRiw4QkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d0ZBQUU7QUFDRix1QkFJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OEZBQUU7QUFDRix5QkFJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFNZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IF9fZGVjb3JhdGUsIF9fbWV0YWRhdGEsIF9fcGFyYW0gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIMm1ybVkZWZpbmVJbmplY3RhYmxlLCDJtcm1aW5qZWN0LCBMT0NBTEVfSUQsIEluamVjdGFibGUsIEluamVjdCwgUGlwZSwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHZhbGlkYXRlUGFja2FnZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1saWNlbnNpbmcnO1xuaW1wb3J0IHsgZGF0ZUZvcm1hdE5hbWVzLCBkYXRlRmllbGROYW1lLCBmaXJzdERheSwgZm9ybWF0LCBmb3JtYXREYXRlLCBmb3JtYXROdW1iZXIsIGxvYWQsIG51bWJlclN5bWJvbHMsIHBhcnNlRGF0ZSwgcGFyc2VOdW1iZXIsIHNwbGl0RGF0ZUZvcm1hdCwgdG9TdHJpbmcsIHdlZWtlbmRSYW5nZSwgc2V0RGF0YSwgbG9jYWxlSW5mbyB9IGZyb20gJ0B0ZWxlcmlrL2tlbmRvLWludGwnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcGFja2FnZU1ldGFkYXRhID0ge1xuICAgIG5hbWU6ICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnRsJyxcbiAgICBwcm9kdWN0TmFtZTogJ0tlbmRvIFVJIGZvciBBbmd1bGFyJyxcbiAgICBwcm9kdWN0Q29kZXM6IFsnS0VORE9VSUFOR1VMQVInLCAnS0VORE9VSUNPTVBMRVRFJ10sXG4gICAgcHVibGlzaERhdGU6IDE2MTEwNTIxNzEsXG4gICAgdmVyc2lvbjogJycsXG4gICAgbGljZW5zaW5nRG9jc1VybDogJ2h0dHBzOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvbXktbGljZW5zZS8/dXRtX21lZGl1bT1wcm9kdWN0JnV0bV9zb3VyY2U9a2VuZG9hbmd1bGFyJnV0bV9jYW1wYWlnbj1rZW5kby11aS1hbmd1bGFyLXB1cmNoYXNlLWxpY2Vuc2Uta2V5cy13YXJuaW5nJ1xufTtcblxuY29uc3QgRE9DU19VUkwgPSAnaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvaW50ZXJuYXRpb25hbGl6YXRpb24vdHJvdWJsZXNob290aW5nLyc7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZXJyb3JTb2x1dGlvbnMgPSB7XG4gICAgJ05vQ3VycmVuY3knOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1jdXJyZW5jeWAsXG4gICAgJ05vQ3VycmVuY3lEaXNwbGF5JzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8tY3VycmVuY3ktZGlzcGxheWAsXG4gICAgJ05vQ3VycmVuY3lSZWdpb24nOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1jdXJyZW5jeS1yZWdpb25gLFxuICAgICdOb0RhdGVGaWVsZE5hbWVzJzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8tZGF0ZS1maWxlZC1uYW1lc2AsXG4gICAgJ05vRmlyc3REYXknOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1maXJzdC1kYXlgLFxuICAgICdOb0dNVEluZm8nOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1nbXQtaW5mb2AsXG4gICAgJ05vTG9jYWxlJzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8tbG9jYWxlYCxcbiAgICAnTm9WYWxpZEN1cnJlbmN5JzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8tdmFsaWQtY3VycmVuY3lgLFxuICAgICdOb1dlZWtEYXRhJzogYFNvbHV0aW9uOiAke0RPQ1NfVVJMfSN0b2Mtbm8td2Vlay1kYXRhYFxufTtcblxuZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShlcnJvcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIGNvbnN0IGVycm9yU29sdXRpb24gPSBlcnJvclNvbHV0aW9uc1tPYmplY3Qua2V5cyhlcnJvclNvbHV0aW9ucykuZmlsdGVyKGtleSA9PiBtZXNzYWdlLmluZGV4T2Yoa2V5KSA9PT0gMClbMF1dO1xuICAgIHJldHVybiBlcnJvclNvbHV0aW9uID8gYCR7bWVzc2FnZX0gJHtlcnJvclNvbHV0aW9ufWAgOiBtZXNzYWdlO1xufVxuZnVuY3Rpb24gaW50bE1ldGhvZChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4udmFsdWVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBmb3JtYXRNZXNzYWdlKGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBkYXRlRm9ybWF0TmFtZXMkMSA9IGludGxNZXRob2QoZGF0ZUZvcm1hdE5hbWVzKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBkYXRlRmllbGROYW1lJDEgPSBpbnRsTWV0aG9kKGRhdGVGaWVsZE5hbWUpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZpcnN0RGF5JDEgPSBpbnRsTWV0aG9kKGZpcnN0RGF5KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBmb3JtYXQkMSA9IGludGxNZXRob2QoZm9ybWF0KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBmb3JtYXREYXRlJDEgPSBpbnRsTWV0aG9kKGZvcm1hdERhdGUpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZvcm1hdE51bWJlciQxID0gaW50bE1ldGhvZChmb3JtYXROdW1iZXIpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGxvYWQkMSA9IGludGxNZXRob2QobG9hZCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbnVtYmVyU3ltYm9scyQxID0gaW50bE1ldGhvZChudW1iZXJTeW1ib2xzKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBwYXJzZURhdGUkMSA9IGludGxNZXRob2QocGFyc2VEYXRlKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBwYXJzZU51bWJlciQxID0gaW50bE1ldGhvZChwYXJzZU51bWJlcik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgc3BsaXREYXRlRm9ybWF0JDEgPSBpbnRsTWV0aG9kKHNwbGl0RGF0ZUZvcm1hdCk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgdG9TdHJpbmckMSA9IGludGxNZXRob2QodG9TdHJpbmcpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHdlZWtlbmRSYW5nZSQxID0gaW50bE1ldGhvZCh3ZWVrZW5kUmFuZ2UpO1xuLyoqXG4gKiBTZXRzIGEgcHJlLWJ1aWx0IGxvY2FsZS5cbiAqXG4gKiBAcGFyYW1zIGRhdGEgLSBUaGUgcHJlLWJ1aWx0IGxvY2FsZSBkYXRhLlxuICovXG5jb25zdCBzZXREYXRhJDEgPSAoZGF0YSkgPT4gc2V0RGF0YShkYXRhKTtcbi8qKlxuICogUmV0cmlldmVzIHRoZSBsb2NhbGUgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCBsb2NhbGUuXG4gKlxuICogQHBhcmFtcyBsb2NhbGUgLSBUaGUgbG9jYWxlIGlkLlxuICogQHJldHVybnMgZGF0YSAtIFRoZSBsb2NhbGUgZGF0YS5cbiAqL1xuY29uc3QgbG9jYWxlRGF0YSA9IChsb2NhbGUpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbG9jYWxlSW5mbyhsb2NhbGUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZXJyb3IubWVzc2FnZSA9IGZvcm1hdE1lc3NhZ2UoZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59O1xuXG5jb25zdCBMT0NBTEVfUkVHRVggPSAvXy9nO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGNsZHJTZXJ2aWNlRmFjdG9yeShsb2NhbGVJZCkge1xuICAgIHJldHVybiBuZXcgQ2xkckludGxTZXJ2aWNlKGxvY2FsZUlkKTtcbn1cbi8qKlxuICogQW4gYWJzdHJhY3QgYmFzZSBjbGFzcyB0aGF0IGltcGxlbWVudHNcbiAqIHRoZSBJbnRlcm5hdGlvbmFsaXphdGlvbiBzZXJ2aWNlIG1ldGhvZHNcbiAqIGZvciB0aGUgY3VycmVudCBsb2NhbGUuXG4gKi9cbmxldCBJbnRsU2VydmljZSA9IGNsYXNzIEludGxTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyB0aGF0IHRoZSBzZXJ2aWNlIHdhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIG5vdGlmeSgpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmVtaXQoKTtcbiAgICB9XG59O1xuSW50bFNlcnZpY2UubmdJbmplY3RhYmxlRGVmID0gybXJtWRlZmluZUluamVjdGFibGUoeyBmYWN0b3J5OiBmdW5jdGlvbiBJbnRsU2VydmljZV9GYWN0b3J5KCkgeyByZXR1cm4gY2xkclNlcnZpY2VGYWN0b3J5KMm1ybVpbmplY3QoTE9DQUxFX0lEKSk7IH0sIHRva2VuOiBJbnRsU2VydmljZSwgcHJvdmlkZWRJbjogXCJyb290XCIgfSk7XG5JbnRsU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoe1xuICAgICAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgICAgIHVzZUZhY3Rvcnk6IGNsZHJTZXJ2aWNlRmFjdG9yeSxcbiAgICAgICAgZGVwczogW0xPQ0FMRV9JRF1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBJbnRsU2VydmljZSk7XG4vKipcbiAqIFRoZSBJbnRlcm5hdGlvbmFsaXphdGlvbiBzZXJ2aWNlIGltcGxlbWVudGVkIGJ5IHVzaW5nXG4gKiB0aGUgQ0xEUiBEYXRhYmFzZSB2aWEgdGhlIGBAdGVsZXJpay9rZW5kby1pbnRsYCBwYWNrYWdlLlxuICovXG5sZXQgQ2xkckludGxTZXJ2aWNlID0gY2xhc3MgQ2xkckludGxTZXJ2aWNlIGV4dGVuZHMgSW50bFNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIHNlcnZpY2Ugd2l0aCB0aGUgSUQgb2YgdGhlIHNwZWNpZmllZCBsb2NhbGUuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIHBhcnRzIG9mIHRoZSBsb2NhbGUgSUQgY2FuIGJlIHNlcGFyYXRlZCBieSBlaXRoZXIgYF9gICh1bmRlcnNjb3JlKVxuICAgICAqIG9yIGAtYCAoZGFzaCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgZGVmYXVsdCBsb2NhbGUgSUQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9jYWxlSWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sb2NhbGVJZCA9IGxvY2FsZUlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgbG9jYWxlIElELlxuICAgICAqL1xuICAgIGdldCBsb2NhbGVJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlO1xuICAgIH1cbiAgICBzZXQgbG9jYWxlSWQodmFsdWUpIHtcbiAgICAgICAgLy8gQW5ndWxhciBsb2NhbGVzIHVzZSB1bmRlcnNjb3JlLCBmb3IgZXhhbXBsZSwgZW5fVVNcbiAgICAgICAgLy8gd2hpbGUgSUVURiBCQ1AtNDcgc3BlY2lmaWVzIGEgZGFzaC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2JjcDQ3XG4gICAgICAgIGNvbnN0IGxvY2FsZSA9IHZhbHVlLnJlcGxhY2UoTE9DQUxFX1JFR0VYLCAnLScpO1xuICAgICAgICBpZiAobG9jYWxlICE9PSB0aGlzLmxvY2FsZSkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgYSBzdHJpbmcgd2l0aCBwbGFjZWhvbGRlcnMgc3VjaCBhc1xuICAgICAqIGBUb3RhbCBhbW91bnQgezA6Y31gLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBPbmUgb3IgbW9yZSB2YWx1ZXMgdG8gb3V0cHV0IGluIHRoZSBmb3JtYXQgc3RyaW5nIHBsYWNlaG9sZGVycy5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGZvcm1hdHRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZm9ybWF0KGZvcm1hdCQkMSwgLi4udmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXQkMShmb3JtYXQkJDEsIHZhbHVlcywgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCB0byB1c2UuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIFRoZSBmb3JtYXR0ZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIHRvU3RyaW5nKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZyQxKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGBEYXRlYCBvYmplY3QgaW50byBhIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICAgKiBJZiBubyBmb3JtYXQgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IHNob3J0IGRhdGUgZm9ybWF0IGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgZGF0ZSB0byBmb3JtYXQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nIG9yIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIFRoZSBmb3JtYXR0ZWQgZGF0ZS5cbiAgICAgKi9cbiAgICBmb3JtYXREYXRlKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXREYXRlJDEodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBgRGF0ZWAgb2JqZWN0IGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZ3Mgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gVGhlIHBhcnNlZCBkYXRlLlxuICAgICAqL1xuICAgIHBhcnNlRGF0ZSh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gcGFyc2VEYXRlJDEodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIGludG8gYSBgTnVtYmVyYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gVGhlIHBhcnNlZCBudW1iZXIuXG4gICAgICovXG4gICAgcGFyc2VOdW1iZXIodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlTnVtYmVyJDEodmFsdWUsIGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQsIGZvcm1hdCQkMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYE51bWJlcmAgaW50byBhIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gZm9ybWF0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiBUaGUgZm9ybWF0dGVkIG51bWJlci5cbiAgICAgKi9cbiAgICBmb3JtYXROdW1iZXIodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlciQxKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkYXRlIG5hbWVzIGZyb20gdGhlIGN1cnJlbnQgbG9jYWxlIGJhc2VkIG9uIHRoZSBvcHRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgYXZhaWxhYmxlIGB0eXBlYCB2YWx1ZXMgYXJlOlxuICAgICAqIC0gYGVyYWBcbiAgICAgKiAtIGB5ZWFyYFxuICAgICAqIC0gYHF1YXJ0ZXJgXG4gICAgICogLSBgbW9udGhgXG4gICAgICogLSBgd2Vla2BcbiAgICAgKiAtIGBkYXlgXG4gICAgICogLSBgZGF5cGVyaW9kYFxuICAgICAqIC0gYGhvdXJgXG4gICAgICogLSBgbWludXRlYFxuICAgICAqIC0gYHNlY29uZGBcbiAgICAgKiAtIGB6b25lYFxuICAgICAqXG4gICAgICogVGhlIGF2YWlsYWJsZSBgbmFtZVR5cGVgIHZhbHVlcyBhcmU6XG4gICAgICogLSBgd2lkZWBcbiAgICAgKiAtIGBuYXJyb3dgXG4gICAgICogLSBgc2hvcnRgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIERldGFpbGVkIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBkZXNpcmVkIGRhdGUgZmllbGQgbmFtZS5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gLSBUaGUgZGF5IG5hbWVzIGZyb20gdGhlIGN1cnJlbnQgbG9jYWxlIGJhc2VkIG9uIHRoZSBvcHRpb24uXG4gICAgICogQHJldHVybnMgVGhlIGxvY2FsaXplZCBkYXRlIGZpZWxkIG5hbWUgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogZGF0ZUZpZWxkTmFtZSh7IHR5cGU6ICdkYXknIH0pOyAgICAgICAgICAgICAgICAgICAgICAvL3JldHVybnMgJ2RheSc7XG4gICAgICogZGF0ZUZpZWxkTmFtZSh7IHR5cGU6ICdkYXknLCBuYW1lVHlwZTogJ3dpZGUnIH0pOyAgICAvL3JldHVybnMgJ2RheSc7XG4gICAgICogZGF0ZUZpZWxkTmFtZSh7IHR5cGU6ICdtb250aCcsIG5hbWVUeXBlOiAnc2hvcnQnIH0pOyAvL3JldHVybnMgJ21vLic7XG4gICAgICogZGF0ZUZpZWxkTmFtZSh7IHR5cGU6ICdtb250aCcsIG5hbWVUeXBlOiAnd2lkZScgfSk7ICAvL3JldHVybnMgJ21vbnRoJztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBkYXRlRmllbGROYW1lKG9wdGlvbnMsIGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBkYXRlRmllbGROYW1lJDEob3B0aW9ucywgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsb2NhbGl6ZWQgZGF0ZSBmaWVsZCBuYW1lIGJhc2VkIG9uIHNwZWNpZmljIGRhdGVGaWVsZE5hbWUgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIFRoZSBhdmFpbGFibGUgdHlwZSB2YWx1ZXMgYXJlOlxuICAgICAqIC0gYGRheWBcbiAgICAgKiAtIGBkYXlwZXJpb2RgXG4gICAgICogLSBgbW9udGhzYFxuICAgICAqIC0gYHF1YXJ0ZXJzYFxuICAgICAqIC0gYGVyYXNgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIERldGFpbGVkIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBkZXNpcmVkIGRhdGUgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiAtIFRoZSBkYXkgbmFtZXMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKi9cbiAgICBkYXRlRm9ybWF0TmFtZXMob3B0aW9ucywgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVGb3JtYXROYW1lcyQxKGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgdGhlIGRhdGUgZm9ybWF0IGludG8gb2JqZWN0cyBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IGVhY2ggcGFydCBvZiB0aGUgcGF0dGVybi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JtYXQgVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgVGhlIG9wdGlvbmFsIGxvY2FsZSBpZC4gSWYgbm90IHNwZWNpZmllZCwgdGhlIGBcImVuXCJgIGxvY2FsZSBpZCBpcyB1c2VkLlxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRlIGZvcm1hdCBwYXJ0cy5cbiAgICAgKi9cbiAgICBzcGxpdERhdGVGb3JtYXQoZm9ybWF0JCQxLCBsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gc3BsaXREYXRlRm9ybWF0JDEoZm9ybWF0JCQxLCBsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIHN5bWJvbHMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiAtIFRoZSBudW1iZXIgc3ltYm9scyBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZS5cbiAgICAgKi9cbiAgICBudW1iZXJTeW1ib2xzKGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBudW1iZXJTeW1ib2xzJDEobG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGRheSBpbmRleCBzdGFydGluZyBmcm9tIFN1bmRheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGxvY2FsZSBJRC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgKDAgPT0gU3VuZGF5KS5cbiAgICAgKi9cbiAgICBmaXJzdERheShsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gZmlyc3REYXkkMShsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RhcnQgYW5kIGVuZCBpbmRleCBvZiB0aGUgbG9jYWxlIHdlZWtlbmQgc3RhcnRpbmcgZnJvbSBTdW5kYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElELiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBsb2NhbGUgSUQuXG4gICAgICogQHJldHVybiAtIFRoZSB0aGUgc3RhcnQgYW5kIGVuZCBpbmRleCBvZiB0aGUgbG9jYWxlIHdlZWtlbmQgKDAgPT0gU3VuZGF5KS5cbiAgICAgKi9cbiAgICB3ZWVrZW5kUmFuZ2UobG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtlbmRSYW5nZSQxKGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbn07XG5DbGRySW50bFNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19wYXJhbSgwLCBJbmplY3QoTE9DQUxFX0lEKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgQ2xkckludGxTZXJ2aWNlKTtcblxuY29uc3QgaXNOdW1lcmljID0gKHZhbHVlKSA9PiAhaXNOYU4odmFsdWUgLSBwYXJzZUZsb2F0KHZhbHVlKSk7XG5jb25zdCDJtTAgPSBpc051bWVyaWM7XG4vKipcbiAqIEZvcm1hdHMgYSBkYXRlIHZhbHVlIHRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSByZXF1ZXN0ZWQgZm9ybWF0LlxuICogVGhpcyBwaXBlIHVzZXMgdGhlIFtJbnRsU2VydmljZV0oeyUgc2x1ZyBhcGlfaW50bF9pbnRsc2VydmljZSAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYG5nLXRlbXBsYXRlLW5vLXJ1blxuICogPHVsPlxuICogICAgPGxpPnt7ZGF0ZSB8IGtlbmRvRGF0ZSB9fTwvbGk+XG4gKiAgICA8bGk+e3ttaWxsaXNlY29uZHMgfCBrZW5kb0RhdGU6ICdNL2RkL3l5eScgfX08L2xpPlxuICogICAgPGxpPnt7c3RyaW5nRGF0ZSB8IGtlbmRvRGF0ZTogJ0cnIH19PC9saT5cbiAqIDwvdWw+XG4gKiBgYGBcbiAqL1xubGV0IERhdGVQaXBlID0gY2xhc3MgRGF0ZVBpcGUge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpbnRsU2VydmljZSkge1xuICAgICAgICB0aGlzLmludGxTZXJ2aWNlID0gaW50bFNlcnZpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYERhdGVgIG9iamVjdCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqIElmIG5vIGZvcm1hdCBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgc2hvcnQgZGF0ZSBmb3JtYXQgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBkYXRlIHRvIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSAoT3B0aW9uYWwpIFRoZSBJRCBvZiB0aGUgbG9jYWxlIHdoaWNoIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IG9uZS5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGZvcm1hdHRlZCBkYXRlLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSh2YWx1ZSwgZm9ybWF0JCQxID0gXCJcIiwgbG9jYWxlSWQpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLm5vcm1hbGl6ZSh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50bFNlcnZpY2UuZm9ybWF0RGF0ZSh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBub3JtYWxpemUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5pbnRsU2VydmljZS5wYXJzZURhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICYmIGlzTnVtZXJpYyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUocGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59O1xuRGF0ZVBpcGUgPSBfX2RlY29yYXRlKFtcbiAgICBQaXBlKHtcbiAgICAgICAgbmFtZTogJ2tlbmRvRGF0ZSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0ludGxTZXJ2aWNlXSlcbl0sIERhdGVQaXBlKTtcblxuLyoqXG4gKiBGb3JtYXRzIGEgbnVtYmVyIHZhbHVlIHRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSByZXF1ZXN0ZWQgZm9ybWF0LlxuICogVGhpcyBwaXBlIHVzZXMgdGhlIFtgSW50bFNlcnZpY2VgXSh7JSBzbHVnIGFwaV9pbnRsX2ludGxzZXJ2aWNlICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgbmctdGVtcGxhdGUtbm8tcnVuXG4gKiAgIDx1bD5cbiAqICAgICA8bGk+e3tkZWNpbWFsIHwga2VuZG9OdW1iZXI6J2MnIH19PC9saT5cbiAqICAgICA8bGk+e3tzdHJpbmdOdW1iZXIgfCBrZW5kb051bWJlcjoncCcgfX08L2xpPlxuICogICAgIDxsaT57e2ludCB8IGtlbmRvTnVtYmVyOicjIy4wMCcgfX08L2xpPlxuICogIDwvdWw+XG4gKiBgYGBcbiAqL1xubGV0IE51bWJlclBpcGUgPSBjbGFzcyBOdW1iZXJQaXBlIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW50bFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5pbnRsU2VydmljZSA9IGludGxTZXJ2aWNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGBOdW1iZXJgIG9iamVjdCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqIElmIG5vIGZvcm1hdCBpcyBwcm92aWRlZCwgdGhlIHZhbHVlIGlzIGZvcm1hdHRlZCBhcyBkZWNpbWFsIG51bWJlciB1c2luZyB0aGVcbiAgICAgKiBbYFwiblwiYF0oaHR0cHM6Ly9naXRodWIuY29tL3RlbGVyaWsva2VuZG8taW50bC9ibG9iL21hc3Rlci9kb2NzL251bS1mb3JtYXR0aW5nL2luZGV4Lm1kI3N0YW5kYXJkKSBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtZXIgdGhhdCB3aWxsIGJlIGZvcm1hdHRlZC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSAoT3B0aW9uYWwpIFRoZSBsb2NhbGUgSUQgdGhhdCB3aWxsIGJlIHVzZWQgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLlxuICAgICAqIEByZXR1cm4gLSBUaGUgZm9ybWF0dGVkIG51bWJlci5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0odmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5pbnRsU2VydmljZS5wYXJzZU51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGxTZXJ2aWNlLmZvcm1hdE51bWJlcih2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG5OdW1iZXJQaXBlID0gX19kZWNvcmF0ZShbXG4gICAgUGlwZSh7XG4gICAgICAgIG5hbWU6ICdrZW5kb051bWJlcidcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0ludGxTZXJ2aWNlXSlcbl0sIE51bWJlclBpcGUpO1xuXG5jb25zdCBwaXBlcyA9IFtcbiAgICBEYXRlUGlwZSxcbiAgICBOdW1iZXJQaXBlXG5dO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbTmdNb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX1kb2NzL3RzL2xhdGVzdC9ndWlkZS9uZ21vZHVsZS5odG1sKVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIEludGwgc2VydmljZXMuXG4gKi9cbmxldCBJbnRsTW9kdWxlID0gY2xhc3MgSW50bE1vZHVsZSB7XG59O1xuSW50bE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbcGlwZXNdLFxuICAgICAgICBleHBvcnRzOiBbcGlwZXNdXG4gICAgfSlcbl0sIEludGxNb2R1bGUpO1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IGNsZHJTZXJ2aWNlRmFjdG9yeSwgSW50bFNlcnZpY2UsIENsZHJJbnRsU2VydmljZSwgRGF0ZVBpcGUsIMm1MCwgTnVtYmVyUGlwZSwgSW50bE1vZHVsZSwgZGF0ZUZvcm1hdE5hbWVzJDEgYXMgZGF0ZUZvcm1hdE5hbWVzLCBkYXRlRmllbGROYW1lJDEgYXMgZGF0ZUZpZWxkTmFtZSwgZmlyc3REYXkkMSBhcyBmaXJzdERheSwgZm9ybWF0JDEgYXMgZm9ybWF0LCBmb3JtYXREYXRlJDEgYXMgZm9ybWF0RGF0ZSwgZm9ybWF0TnVtYmVyJDEgYXMgZm9ybWF0TnVtYmVyLCBsb2FkJDEgYXMgbG9hZCwgbnVtYmVyU3ltYm9scyQxIGFzIG51bWJlclN5bWJvbHMsIHBhcnNlRGF0ZSQxIGFzIHBhcnNlRGF0ZSwgcGFyc2VOdW1iZXIkMSBhcyBwYXJzZU51bWJlciwgc3BsaXREYXRlRm9ybWF0JDEgYXMgc3BsaXREYXRlRm9ybWF0LCB0b1N0cmluZyQxIGFzIHRvU3RyaW5nLCB3ZWVrZW5kUmFuZ2UkMSBhcyB3ZWVrZW5kUmFuZ2UsIHNldERhdGEkMSBhcyBzZXREYXRhLCBsb2NhbGVEYXRhIH07XG4iXX0=